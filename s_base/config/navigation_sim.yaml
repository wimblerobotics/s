amcl:
  ros__parameters:
    use_sim_time: true
    alpha1: 0.20 #0.2  # Expected process noise in odometry’s rotation estimate from rotation.
    alpha2: 0.20 #0.2  # Expected process noise in odometry’s rotation estimate from translation.
    alpha3: 0.20 #0.2  # Expected process noise in odometry’s translation estimate from translation.
    alpha4: 0.20 #0.2  # Expected process noise in odometry’s translation estimate from rotation.
    alpha5: 0.20       # For Omni models only: translation noise.
    base_frame_id: "base_footprint"
    beam_skip_distance: 0.5 # Ignore beams that most particles disagree with in Likelihood field model. Maximum distance to consider skipping for (m).
    beam_skip_error_threshold: 0.9  # Percentage of beams after not matching map to force full update due to bad convergance.
    beam_skip_threshold: 0.3  # Percentage of beams required to skip.
    do_beamskip: false  # Whether to do beam skipping in Likelihood field model.
    global_frame_id: "map"  # The name of the coordinate frame published by the localization system.
    lambda_short: 0.1   # Exponential decay parameter for z_short part of model.
    laser_likelihood_max_dist: 2.0 # Maximum distance to do obstacle inflation on map, for use in likelihood_field model.
    laser_max_range: -1.0   # Maximum scan range to be considered, -1.0 will cause the laser’s reported maximum range to be used.
    laser_min_range: -1.0   # Minimum scan range to be considered, -1.0 will cause the laser’s reported minimum range to be used.
    laser_model_type: "likelihood_field" # Which model to use, either beam, likelihood_field, or likelihood_field_prob.
    max_beams: 450          # How many evenly-spaced beams in each scan to be used when updating the filter.
    max_particles: 2000     # Maximum allowed number of particles.
    min_particles: 1000     # Minimum allowed number of particles.
    odom_frame_id: "odom"   # Which frame to use for odometry.
    pf_err: 0.05            # Particle Filter population error.  
    pf_z: 0.99              # Particle filter population density.
    recovery_alpha_fast: 0.01  # Exponential decay rate for the fast average weight filter, used in deciding when to recover by adding random poses.
    recovery_alpha_slow: 0.001 # Exponential decay rate for the slow average weight filter, used in deciding when to recover by adding random poses. A good value might be 0.001.
    resample_interval: 1    # Number of filter updates required before resampling.
    robot_model_type: "nav2_amcl::DifferentialMotionModel" # The fully-qualified type of the plugin class.
    save_pose_rate: 0.5     # Maximum rate (Hz) at which to store the last estimated pose and covariance to the parameter server.
    sigma_hit: 0.2          # Standard deviation for Gaussian model used in z_hit part of the model.
    tf_broadcast: true      # Set this to false to prevent amcl from publishing the transform between the global frame and the odometry frame.
    transform_tolerance: 0.3 # Time with which to post-date the transform that is published, to indicate that this transform is valid into the future.
    # One degree = 0.017453278 radians
    update_min_a: 0.01745   # Rotational movement required before performing a filter update.
    update_min_d: 0.05      # Translational movement required before performing a filter update.
    z_hit: 0.95             # Mixture weight for z_hit part of model, sum of all used z weight must be 1. 
    z_max: 0.001            # Mixture weight for z_max part of model, sum of all used z weight must be 1. Beam uses all 4, likelihood model uses z_hit and z_rand.
    z_rand: 0.05            # Mixture weight for z_rand part of model, sum of all used z weight must be 1.
    z_short: 0.001          # Mixture weight for z_short part of model, sum of all used z weight must be 1.
    scan_topic: scan
    set_initial_pose: true # Causes AMCL to set initial pose from the initial_pose* parameters instead of waiting for the initial_pose message.
    initial_pose:
      x: 1.0 #8.0 #8.25
      y: 1.0 #3.0 #3.145
      yaw:  1.571 # 1.571


amcl_map_client:
  ros__parameters:
    use_sim_time: true

amcl_rclcpp_node:
  ros__parameters:
    use_sim_time: true

bt_navigator:
  ros__parameters:
    use_sim_time: true
    global_frame: map
    robot_base_frame: base_link
    odom_topic: /odom
    bt_loop_duration: 10
    default_server_timeout: 20
    enable_groot_monitoring: true
    groot_zmq_publisher_port: 1666
    groot_zmq_server_port: 1667
    plugin_lib_names:
    - nav2_compute_path_to_pose_action_bt_node
    - nav2_compute_path_through_poses_action_bt_node
    - nav2_follow_path_action_bt_node
    - nav2_back_up_action_bt_node
    - nav2_spin_action_bt_node
    - nav2_wait_action_bt_node
    - nav2_clear_costmap_service_bt_node
    - nav2_is_stuck_condition_bt_node
    - nav2_goal_reached_condition_bt_node
    - nav2_goal_updated_condition_bt_node
    - nav2_initial_pose_received_condition_bt_node
    - nav2_reinitialize_global_localization_service_bt_node
    - nav2_rate_controller_bt_node
    - nav2_distance_controller_bt_node
    - nav2_speed_controller_bt_node
    - nav2_truncate_path_action_bt_node
    - nav2_goal_updater_node_bt_node
    - nav2_recovery_node_bt_node
    - nav2_pipeline_sequence_bt_node
    - nav2_round_robin_node_bt_node
    - nav2_transform_available_condition_bt_node
    - nav2_time_expired_condition_bt_node
    - nav2_distance_traveled_condition_bt_node
    - nav2_single_trigger_bt_node
    - nav2_is_battery_low_condition_bt_node
    - nav2_navigate_through_poses_action_bt_node
    - nav2_navigate_to_pose_action_bt_node
    - nav2_remove_passed_goals_action_bt_node
    - nav2_planner_selector_bt_node
    - nav2_controller_selector_bt_node
    - nav2_goal_checker_selector_bt_node

bt_navigator_rclcpp_node:
  ros__parameters:
    use_sim_time: true

controller_server:
  ros__parameters:
    controller_frequency: 20.0 # Frequency to run controller (Hz). cmd_vel will be published at the frequency.
    controller_plugins: ["FollowPath"] # List of mapped names for controller plugins for processing requests and parameters.
    failure_tolerance: 0.3 # Max duration controller plugin can fail before FollowPath action fails.
    goal_checker_plugins: ["general_goal_checker"] # Mapped name for goal checker plugin for checking goal is reached. 
    min_theta_velocity_threshold: 0.001 # Set cmd_vel theta-velocity to zero if less than this.
    min_x_velocity_threshold: 0.001 # Set cmd_vel x-velocity to zero if less than this.
    min_y_velocity_threshold: 0.0 # Set cmd_vel y-velocity to zero if less than this.
    odom_topic: "odom" # Topic to get instantaneous measurement of speed from
    progress_checker_plugins: ["progress_checker"] # Mapped name for progress checker plugin for checking progress made by robot.
    speed_limit_topic: "speed_limit" # Speed limiting topic name to subscribe.
    use_realtime_priority: False # Note, requires edit of /etc/security/limits.conf
    use_sim_time: False

    # Progress checker parameters
    progress_checker:
      plugin: "nav2_controller::SimpleProgressChecker"
      movement_time_allowance: 3.0 # Maximum amount of time a robot has to move the minimum radius (s).
      required_movement_radius: 0.2 # Minimum amount a robot must move to be progressing to goal (m).

    # Goal checker parameters
    general_goal_checker:
      plugin: "nav2_controller::SimpleGoalChecker"
      stateful: True # True => goal checker will not check if the xy position matches again once it is found to be true.
      xy_goal_tolerance: 0.0508       # Tolerance to meet goal completion criteria (m).
      yaw_goal_tolerance: 0.08726639  # Tolerance to meet goal completion criteria (rad).

    # DWB parameters
    FollowPath:
      # KinematicsHandler parameters
      acc_lim_theta: 5.0      # Maximum acceleration theta (rad/s^2).
      acc_lim_x: 2.5          # Maximum acceleration X (m/s^2).
      acc_lim_y: 0.0          # Maximum acceleration Y (m/s^2).
      decel_lim_theta: -5.0   # Maximum deceleration theta (rad/s^2).
      decel_lim_x: -2.5       # Maximum deceleration X (m/s^2).
      decel_lim_y: 0.0        # Maximum deceleration Y (m/s^2).
      max_speed_xy: 0.26      # Maximum translational speed (m/s).
      max_vel_theta: 3.14     # Maximum angular velocity (rad/s).
      max_vel_x: 0.5          # Maximum velocity X (m/s).
      max_vel_y: 0.0          # Maximum velocity Y (m/s).
      min_speed_theta: -3.14  # Minimum angular speed (rad/s).
      min_speed_xy: 0.0       # Minimum translational speed (m/s).
      min_vel_x: -0.01        # Minimum velocity X (m/s).
      min_vel_y: 0.0          # Minimum velocity Y (m/s).
      xy_goal_tolerance: 0.05 # Tolerance to meet goal completion criteria (m).

      # Publisher parameters
      marker_lifetime: 0.2              # Lifetime of the markers (s).
      publish_cost_grid_pc: False       # Whether to publish the cost grid as a PointCloud.
      publish_evaluation: False         # Whether to publish the evaluation of the trajectory.
      publish_global_plan: True         # Whether to publish the global plan.
      publish_local_plan: True          # Whether to publish the local plan.
      publish_transformed_plan: False   # Whether to publish the transformed plan.
      publish_trajectories: False       # Whether to publish the trajectories.

      # StandardTrajectoryGenerator parameters
      angular_granularity: 0.025  # Granularity of the trajectory (rad).
      discretize_by_time: True   # Whether to discretize the trajectory by time or by distance.
      include_last_point: True    # Whether to include the last point in the trajectory.
      linear_granularity: 0.05    # Granularity of the trajectory (m).
      sim_time: 2.0               # Time to simulate ahead by (s).
      time_granularity: 0.05       # Time between points in the trajectory (s).

      # XYThetaIterator parameters
      vtheta_samples: 50  # Number of velocity samples in the angular directions.
      vx_samples: 20      # Number of velocity samples in the X velocity direction.
      vy_samples: 20      # Number of velocity samples in the Y velocity direction.

      # DWB Controller parameters.
      debug_trajectory_details: False           # Whether to log the trajectory details for debugging.
      default_critic_namespaces: ["dwb_critics"]  # Namespaces to load critics in.
      forward_prune_distance: 1.0               # If prune_plan => true, prune the plan to this distance in 
                                                # front of the robot's current pose (m).
      goal_checker_name: "nav2_controller::SimpleGoalChecker" # Name of the goal checker plugin.
      plugin: "dwb_core::DWBLocalPlanner"
      prune_distance: 0.1                      # Distance to prune global path behind robot's current pose (m),
                                                # If prune_plan => True
      prune_plan: True                          # If true, ignore poses along the global path
                                                # that are further than prune_distance away from the robot.
      short_circuit_trajectory_evaluation: True # As critics are applied to a trajectory, if the running sum 
                                                # is greater than the best score found so far, stop applying 
                                                # further critics for the trajectory as they cannot improve the score.
      shorten_transformed_plan: True            # If true, only consider part of the transformed plan that is 
                                                # within the local costmap.
      trajectory_generator_name: "dwb_plugins::StandardTrajectoryGenerator" # To generate the trajectories.
      transform_tolerance: 0.3                  # Time to wait for transform to be available before erroring out.
    
      critics:                    
        # List of critics to use in scoring trajectories. Must not be empty.
        # Order is not important.
        [
        "BaseObstacle",
        "GoalAlign",
        "GoalDist",
        "ObstacleFootprint",
        "PathAlign",
        "PathDist",
        # "PreferForward",
        "RotateToGoal"
        ]

      BaseObstacle:
        # Scores a trajectory based on where the path passes over the costmap. 
        # To use this properly, you must use the inflation layer in costmap
        # to expand obstacles by the robot’s radius.
        aggregation_type: "sum"
        scale: 0.02   # If sum_score is false, the score is based on the cell value corresponding to the last
                      # pose in the trajectory. Otherwise the score is base on the sum of all
                      # the cell values corresponding to the poses in the trajectory.
        sum_score: True
      GoalAlign:
        # Scores a trajectory based on how well aligned the trajectory is with the goal pose.
        scale: 24.0
        forward_point_distance: 0.1 # Point in front of robot to look ahead to compute angular change from.
      GoalDist:
        # Scores a trajectory based on how close the trajectory gets the robot to the goal pose.
        aggregation_type: "last"
        scale: 20.0
      ObstacleFootprint:
        # Scores a trajectory based on verifying all points along the robot’s
        # footprint don’t touch an obstacle marked in the costmap.
        scale: 0.5
      PathAlign:
        # Scores a trajectory based on how well it is aligned to the path provided by the global planner.
        aggregation_type: "last"
        forward_point_distance: 0.23 # Point in front of robot to look ahead to compute angular change from.
        scale: 8.0
      PathDist:
        # Scores a trajectory based on how well it is aligned to the path provided by the global planner.
        aggregation_type: "last"
        scale: 10.0
      PreferForward:
        penalty: 1.0        # Score result if the trajectory isn’t forward (i.e., positive x velocity, small theta velocity).
        scale: 5.0
        strafe_theta: 0.2   # If the x velocity is less than strafe_x, then if the absolute value of the theta velocity
                            # is less than this the score is penalty.
        strafe_x: 0.1       # If x velocity is less than this, ignore it and look at the theta velocity.
        theta_scale: 10.0   # If the robot is moving sufficiently forward, the result is theta_scale times the theta velocity.
      RotateToGoal:
        # Only allows the robot to rotate to the goal orientation when it is sufficiently close to the goal location.
        lookahead_time: 1.0     # If not negative, the yaw score is the yaw of a trajectory point
                                # projected this distance ahead of the last pose in the trajectory.
                                # If negative, the yaw score is simply the yaw of the last pose
                                # in the trajectory.
        scale: 6.0
        slowing_factor: 5.0     # If the robot is near the goal and not rotating, the score is the velocity
                                # times slowing_factor, plus the difference between the current
                                # yaw score and the goal yaw.
        trans_stopped_velocity: 0.01 # If the robot is moving slower than this, it is considered to be rotating only.
        xy_goal_tolerance: 0.05  # If the robot is further than this distance from the goal,
                                # return a score of 0.0.

controller_server_rclcpp_node:
  ros__parameters:
    use_sim_time: True

local_costmap:
  local_costmap:
    ros__parameters:
      always_send_full_costmap: True # Whether to send full costmap every update, rather than updates.
      # footprint_padding: 0.0254 # 0.0508 # Amount to pad footprint (m).
      # footprint: "[[-0.260, -0.170], 
      #              [-0.260, 0.170], [-0.110, 0.170], [-0.110, 0.205], [0.110, 0.205], [0.110, 0.170], [0.290, 0.170],
      #              [0.290, -0.170],
      #              [0.110, -0.170], [0.110, -0.205], [-0.110, -0.205], [-0.110, -0.170]]"
      global_frame: odom
      height: 3 # Height of costmap (m).
      initial_transform_timeout: 60.0 # Time to wait for transform to be available before erroring out.
      lethal_cost_threshold: 100 # Minimum cost of an occupancy grid map to be considered a lethal obstacle.
      map_topic: /map # Topic of map from map_server or SLAM.
      origin_x: 0.0 # X origin of the costmap relative to width (m).
      origin_y: 0.0 # Y origin of the costmap relative to height (m).
      publish_frequency: 2.0 # Frequency to publish costmap to topic.
      resolution: 0.0254 # Resolution of 1 pixel of the costmap, in meters.
      robot_base_frame: base_link
      robot_radius: 0.02 ###0.22
      rolling_window: true # Whether costmap should roll with robot base frame.
      track_unknown_space: True # If false, treats unknown space as free space, else as unknown space.
      transform_tolerance: 0.3 # TF transform tolerance.
      trinary_costmap: True # Whether to use trinary or continuous costmap.
      unknown_cost_value: 255 # Cost of unknown space if tracking it.
      update_frequency: 5.0 # Costmap update frequency.
      use_sim_time: True
      width: 3 # Width of costmap (m).


      plugins: ["lidar_layer", "inflation_layer"]
      inflation_layer:
        enabled: True
        cost_scaling_factor: 64.0     # Exponential decay factor across inflation radius.
        inflate_around_unknown: False # Whether to inflate unknown cells.
        inflate_unknown: False        # Whether to inflate unknown space.
        inflation_radius: 0.15         # Radius to inflate costmap around lethal obstacles.
        plugin: "nav2_costmap_2d::InflationLayer"

      lidar_layer:
        enabled: True
        combination_method: 1 # 0 => Overwrite, 1 => >Max, 2 => MaxWithoutUnknownOverwrite
        footprint_clearing_enabled: True # Clear any occupied cells under robot footprint.
        max_obstacle_height: 1.0 # Maximum height to add return to occupancy grid.
        map_subscribe_transient_local: True
        observation_sources: scan
        plugin: "nav2_costmap_2d::ObstacleLayer"
        scan:
          clearing: True # Whether source should raytrace clear in costmap.
          # expected_update_rate: 0.0 # Expected rate to get new data from sensor.
          data_type: "LaserScan" # Data type of input, LaserScan or PointCloud2.
          inf_is_valid: True # Are infinite returns from laser scanners valid measurements to raycast.
          marking: True # Whether source should mark in costmap.
          max_obstacle_height: 2.0 # Maximum height to add return to occupancy grid.
          min_obstacle_height: 0.0 # Minimum height to add return to occupancy grid.
          obstacle_max_range: 2.4 # Maximum range to mark obstacles in costmap.
          obstacle_min_range: 0.0 # Minimum range to mark obstacles in costmap.
          raytrace_max_range: 3.0 # Maximum range to raytrace clear obstacles from costmap.
          raytrace_min_range: 0.0 # Minimum range to raytrace clear obstacles from costmap.
          topic: /scan # Topic of data.

global_costmap:
  global_costmap:
    ros__parameters:
      always_send_full_costmap: True # Whether to send full costmap every update, rather than updates.
      # footprint_padding: 0.1 # Amount to pad footprint (m).
      # footprint: "[[-0.260, -0.170], 
      #              [-0.260, 0.170], [-0.110, 0.170], [-0.110, 0.205], [0.110, 0.205], [0.110, 0.170], [0.290, 0.170],
      #              [0.290, -0.170],
      #              [0.110, -0.170], [0.110, -0.205], [-0.110, -0.205], [-0.110, -0.170]]"
      global_frame: map
      publish_frequency: 1.0 # Frequency to publish costmap to topic.
      robot_base_frame: base_link
      robot_radius: 0.22
      resolution: 0.0508 # Resolution of 1 pixel of the costmap, in meters.
      track_unknown_space: True # If false, treats unknown space as free space, else as unknown space.
      update_frequency: 1.0 # Costmap update frequency.
      use_sim_time: True
      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]
      obstacle_layer:
        plugin: "nav2_costmap_2d::ObstacleLayer"
        enabled: True
        observation_sources: scan
        scan:
          topic: /scan
          max_obstacle_height: 2.0
          clearing: True
          marking: True
          data_type: "LaserScan"
          raytrace_max_range: 3.0
          raytrace_min_range: 0.0
          obstacle_max_range: 2.5
          obstacle_min_range: 0.0
      static_layer:
        plugin: "nav2_costmap_2d::StaticLayer"
        map_subscribe_transient_local: True
      inflation_layer:
        cost_scaling_factor: 3.0 # Exponential decay factor across inflation radius.
        enabled: True
        # inflate_around_unknown: False # Whether to inflate unknown cells.
        # inflate_unknown: False # Whether to inflate unknown space.
        inflation_radius: 0.6 # Radius to inflate costmap around lethal obstacles.
        plugin: "nav2_costmap_2d::InflationLayer"
      # inflation_layer:
      #   plugin: "nav2_costmap_2d::InflationLayer"
      #   cost_scaling_factor: 3.0
      #   inflation_radius: 0.55


# global_costmap:
#   global_costmap:
#     ros__parameters:
#       always_send_full_costmap: True # Whether to send full costmap every update, rather than updates.
#       # footprint_padding: 0.1 # Amount to pad footprint (m).
#       # footprint: "[[-0.260, -0.170], 
#       #              [-0.260, 0.170], [-0.110, 0.170], [-0.110, 0.205], [0.110, 0.205], [0.110, 0.170], [0.290, 0.170],
#       #              [0.290, -0.170],
#       #              [0.110, -0.170], [0.110, -0.205], [-0.110, -0.205], [-0.110, -0.170]]"
#       global_frame: map
#       publish_frequency: 1.0 # Frequency to publish costmap to topic.
#       robot_base_frame: base_link
#       robot_radius: 0.22
#       resolution: 0.0508 # Resolution of 1 pixel of the costmap, in meters.
#       track_unknown_space: True # If false, treats unknown space as free space, else as unknown space.
#       update_frequency: 1.0 # Costmap update frequency.
#       use_sim_time: True

#       plugins: ["static_layer", "lidar_layer", "inflation_layer"]
#       inflation_layer:
#         cost_scaling_factor: 2.0 # Exponential decay factor across inflation radius.
#         enabled: True
#         inflate_around_unknown: False # Whether to inflate unknown cells.
#         inflate_unknown: False # Whether to inflate unknown space.
#         inflation_radius: 0.2 # Radius to inflate costmap around lethal obstacles.
#         plugin: "nav2_costmap_2d::InflationLayer"
#       lidar_layer:
#         enabled: True
#         combination_method: 1 # 0 => Overwrite, 1 => >Max, 2 => MaxWithoutUnknownOverwrite
#         footprint_clearing_enabled: True # Clear any occupied cells under robot footprint.
#         max_obstacle_height: 1.0 # Maximum height to add return to occupancy grid.
#         map_subscribe_transient_local: True
#         observation_sources: scan
#         plugin: "nav2_costmap_2d::ObstacleLayer"
#         scan:
#           clearing: True # Whether source should raytrace clear in costmap.
#           # expected_update_rate: 0.0 # Expected rate to get new data from sensor.
#           data_type: "LaserScan" # Data type of input, LaserScan or PointCloud2.
#           inf_is_valid: True # Are infinite returns from laser scanners valid measurements to raycast.
#           marking: True # Whether source should mark in costmap.
#           max_obstacle_height: 2.0 # Maximum height to add return to occupancy grid.
#           min_obstacle_height: 0.0 # Minimum height to add return to occupancy grid.
#           obstacle_max_range: 2.4 # Maximum range to mark obstacles in costmap.
#           obstacle_min_range: 0.0 # Minimum range to mark obstacles in costmap.
#           raytrace_max_range: 3.0 # Maximum range to raytrace clear obstacles from costmap.
#           raytrace_min_range: 0.0 # Minimum range to raytrace clear obstacles from costmap.
#           topic: /scan # Topic of data.

#       static_layer:
#         plugin: "nav2_costmap_2d::StaticLayer"
#         map_subscribe_transient_local: True

map_server:
  ros__parameters:
    use_sim_time: True
    yaml_filename: "turtlebot3_world.yaml"

map_saver:
  ros__parameters:
    use_sim_time: True
    save_map_timeout: 5.0
    free_thresh_default: 0.25
    occupied_thresh_default: 0.65
    map_subscribe_transient_local: true

planner_server:
  ros__parameters:
    expected_planner_frequency: 20.0
    use_sim_time: True
    planner_plugins: ["GridBased"]
    GridBased:
      plugin: "nav2_navfn_planner/NavfnPlanner"
      tolerance: 0.5
      use_astar: false
      allow_unknown: true

    # GridBased:
    #   plugin: "nav2_smac_planner/SmacPlannerHybrid"
    #   tolerance: 0.5                      # tolerance for planning if unable to reach exact pose, in meters
    #   downsample_costmap: false           # whether or not to downsample the map
    #   downsampling_factor: 2              # multiplier for the resolution of the costmap layer (e.g. 2 on a 5cm costmap would be 10cm)
    #   allow_unknown: false                # allow traveling in unknown space
    #   max_iterations: 1000000             # maximum total iterations to search for before failing (in case unreachable), set to -1 to disable
    #   max_on_approach_iterations: 1000    # maximum number of iterations to attempt to reach goal once in tolerance
    #   max_planning_time: 3.5              # max time in s for planner to plan, smooth, and upsample. Will scale maximum smoothing and upsampling times based on remaining time after planning.
    #   motion_model_for_search: "DUBIN"    # For Hybrid Dubin, Redds-Shepp
    #   cost_travel_multiplier: 2.0         # For 2D: Cost multiplier to apply to search to steer away from high cost areas. Larger values will place in the center of aisles more exactly (if non-`FREE` cost potential field exists) but take slightly longer to compute. To optimize for speed, a value of 1.0 is reasonable. A reasonable tradeoff value is 2.0. A value of 0.0 effective disables steering away from obstacles and acts like a naive binary search A*.
    #   angle_quantization_bins: 72         # For Hybrid nodes: Number of angle bins for search, must be 1 for 2D node (no angle search)
    #   analytic_expansion_ratio: 3.5       # For Hybrid/Lattice nodes: The ratio to attempt analytic expansions during search for final approach.
    #   analytic_expansion_max_length: 3.0    # For Hybrid/Lattice nodes: The maximum length of the analytic expansion to be considered valid to prevent unsafe shortcutting (in meters). This should be scaled with minimum turning radius and be no less than 4-5x the minimum radius
    #   analytic_expansion_max_cost: true   # For Hybrid/Lattice nodes: The maximum single cost for any part of an analytic expansion to contain and be valid (except when necessary on approach to goal)
    #   analytic_expansion_max_cost_override: false  #  For Hybrid/Lattice nodes: Whether or not to override the maximum cost setting if within critical distance to goal (ie probably required)
    #   minimum_turning_radius: 0.1        # For Hybrid/Lattice nodes: minimum turning radius in m of path / vehicle
    #   reverse_penalty: 1.1                # For Reeds-Shepp model: penalty to apply if motion is reversing, must be => 1
    #   change_penalty: 0.0                 # For Hybrid nodes: penalty to apply if motion is changing directions, must be >= 0
    #   non_straight_penalty: 1.20          # For Hybrid nodes: penalty to apply if motion is non-straight, must be => 1
    #   cost_penalty: 2.0                   # For Hybrid nodes: penalty to apply to higher cost areas when adding into the obstacle map dynamic programming distance expansion heuristic. This drives the robot more towards the center of passages. A value between 1.3 - 3.5 is reasonable.
    #   retrospective_penalty: 0.025        # For Hybrid/Lattice nodes: penalty to prefer later maneuvers before earlier along the path. Saves search time since earlier nodes are not expanded until it is necessary. Must be >= 0.0 and <= 1.0
    #   rotation_penalty: 0.05               # For Lattice node: Penalty to apply only to pure rotate in place commands when using minimum control sets containing rotate in place primitives. This should always be set sufficiently high to weight against this action unless strictly necessary for obstacle avoidance or there may be frequent discontinuities in the plan where it requests the robot to rotate in place to short-cut an otherwise smooth path for marginal path distance savings.
    #   lookup_table_size: 20.0               # For Hybrid nodes: Size of the dubin/reeds-sheep distance window to cache, in meters.
    #   cache_obstacle_heuristic: True      # For Hybrid nodes: Cache the obstacle map dynamic programming distance expansion heuristic between subsiquent replannings of the same goal location. Dramatically speeds up replanning performance (40x) if costmap is largely static.  
    #   allow_reverse_expansion: False      # For Lattice nodes: Whether to expand state lattice graph in forward primitives or reverse as well, will double the branching factor at each step.   
    #   smooth_path: True                   # For Lattice/Hybrid nodes: Whether or not to smooth the path, always true for 2D nodes.
    #   debug_visualizations: True                # For Hybrid/Lattice nodes: Whether to publish expansions on the /expansions topic as an array of poses (the orientation has no meaning) and the path's footprints on the /planned_footprints topic. WARNING: heavy to compute and to display, for debug only as it degrades the performance. 
    #   smoother:
    #     max_iterations: 1000
    #     w_smooth: 0.3
    #     w_data: 0.2
    #     tolerance: 0.0000001
    #     do_refinement: true   

planner_server_rclcpp_node:
  ros__parameters:
    use_sim_time: True

recoveries_server:
  ros__parameters:
    costmap_topic: local_costmap/costmap_raw
    footprint_topic: local_costmap/published_footprint
    cycle_frequency: 10.0
    recovery_plugins: ["spin", "backup", "wait"]
    spin:
      plugin: "nav2_recoveries/Spin"
    backup:
      plugin: "nav2_recoveries/BackUp"
    wait:
      plugin: "nav2_recoveries/Wait"
    global_frame: odom
    robot_base_frame: base_link
    transform_timeout: 0.1
    use_sim_time: True
    simulate_ahead_time: 2.0
    max_rotational_vel: 4.0
    min_rotational_vel: 0.4
    rotational_acc_lim: 3.2

robot_state_publisher:
  ros__parameters:
    use_sim_time: True

waypoint_follower:
  ros__parameters:
    loop_rate: 20
    stop_on_failure: false
    use_sim_time: True
    waypoint_task_executor_plugin: "wait_at_waypoint"   
    wait_at_waypoint:
      plugin: "nav2_waypoint_follower::WaitAtWaypoint"
      enabled: true
      waypoint_pause_duration: 200
